[{"categories":["操作系统"],"content":"关于惊群效应的简单介绍和总结","date":"2022-08-28","objectID":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/","tags":["进程线程并发"],"title":"惊群效应","uri":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/"},{"categories":["操作系统"],"content":"1.简介 当你往一群鸽子中间扔一块食物，虽然最终只有一个鸽子抢到食物，但所有鸽子都会被惊动来争夺，没有抢到食物的鸽子只好回去继续睡觉， 等待下一块食物到来。这样，每扔一块食物，都会惊动所有的鸽子，即为惊群。 操作系统的惊群 在多进程/多线程等待同一资源时，也会出现惊群。即当某一资源可用时，多个进程/线程会惊醒，竞争资源。 2.惊群的影响 惊醒所有进程/线程，导致n-1个进程/线程做了无效的调度，上下文切换，cpu瞬时增高 多个进程/线程争抢资源，所以涉及到同步问题，需对资源进行加锁保护，加解锁加大系统CPU开销 但在某些情况，惊群次数少，进（线）程负载不高，惊群可以忽略不计 3.惊群的情况 accept惊群 epoll惊群 nginx惊群 线程池惊群 ","date":"2022-08-28","objectID":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/:0:0","tags":["进程线程并发"],"title":"惊群效应","uri":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/"},{"categories":["操作系统"],"content":"3.1 accept惊群 新版内核已解决 以多进程为例，在主进程创建监听描述符listenfd后，fork()多个子进程，多个进程共享listenfd，accept是在每个子进程中，当一个新连接来的时候，会发生惊群。 主线程创建了监听描述符listenfd = 3 主线程fork三个子进程，共享listenfd=3 当有新连接进来时，内核进行处理 在内核2.6之前，所有进程accept都会惊醒，但只有一个可以accept成功，其他返回EGAIN。 在内核2.6及之后，解决了惊群，在内核中增加了一个互斥等待变量。一个互斥等待的行为与睡眠基本类似，主要的不同点在于： 1）当一个等待队列入口有 WQ_FLAG_EXCLUSEVE 标志置位, 它被添加到等待队列的尾部；没有这个标志的入口项，相反, 添加到开始。 2）当 wake_up 被在一个等待队列上调用时, 它在唤醒第一个有 WQ_FLAG_EXCLUSIVE 标志的进程后停止。 对于互斥等待的行为，比如对一个listen后的socket描述符，多线程阻塞accept时，系统内核只会唤醒所有正在等待此时间的队列的第一个，队列中的其他人则继续等待下一次事件的发生，这样就避免的多个线程同时监听同一个socket描述符时的惊群问题。 ","date":"2022-08-28","objectID":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/:1:0","tags":["进程线程并发"],"title":"惊群效应","uri":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/"},{"categories":["操作系统"],"content":"3.2 epoll惊群 ","date":"2022-08-28","objectID":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/:2:0","tags":["进程线程并发"],"title":"惊群效应","uri":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/"},{"categories":["操作系统"],"content":"3.2.1 fork之前创建epollfd 新版内核(2.6之后)已解决 主进程创建listenfd, 创建epollfd 主进程fork多个子进程 每个子进程把listenfd,加到epollfd中 当一个连接进来时，会触发epoll惊群，多个子进程的epoll同时会触发 这里的epoll惊群跟accept惊群是类似的，共享一个epollfd, 可以通过加锁或标记解决。 ","date":"2022-08-28","objectID":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/:2:1","tags":["进程线程并发"],"title":"惊群效应","uri":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/"},{"categories":["操作系统"],"content":"3.2.2 fork之后创建epollfd 内核未解决 主进程创建listendfd 主进程fork创建多个子进程 每个子进程创建自已的epollfd 每个子进程把listenfd加入到epollfd中 当一个连接进来时，会触发epoll惊群，多个子进程epoll同时会触发 因为每个子进程的epoll是不同的epoll，虽然listenfd是同一个，但新连接过来时, accept会触发惊群，但内核不知道该发给哪个监听进程，因为不是同一个epoll。所以这种惊群内核并没有处理。惊群还是会出现。 ","date":"2022-08-28","objectID":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/:2:2","tags":["进程线程并发"],"title":"惊群效应","uri":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/"},{"categories":["操作系统"],"content":"3.3 Nginx惊群 在nginx中使用的epoll，是在创建进程后创建的epollfd。因些会出现惊群问题。即每个子进程worker都会惊醒。 Nginx流程： 1 主线程创建listenfd 2 主线程fork多个子进程（根据配置） 3 子进程创建epollfd 4 获到accept锁，只有一个子进程把listenfd加到epollfd中 同一时间只有一个进程会把监听描述符加到epoll中 5 循环监听 nginx里采用了主动的方法去把监听描述符放到epoll中或从epoll移出（这个是nginx的精髓所在，因为大部份的并发架构都是被动的） nginx中用采互斥锁去解决谁来accept问题，保证了同一时刻，只有一个worker接收新连接（所以nginx并没有惊群问题） nginx根据自已的载负（最大连接的7/8）情况，决定去不去抢锁，简单方便地解决负载，防止进程因业务太多而导致所有业务都不及时处理 ","date":"2022-08-28","objectID":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/:3:0","tags":["进程线程并发"],"title":"惊群效应","uri":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/"},{"categories":["操作系统"],"content":"3.4线程池惊群 当一个线程解锁并通知其他线程的时候，就会出现惊群的现象 正常的用法： 所有线程共用一个锁，共用一个条件变量 当pthread_cond_signal通知时，就可能会出现惊群 解决惊群的方法： 所有线程共用一个锁，每个线程有自已的条件变量 pthread_cond_signal通知时，定向通知某个线程的条件变量，不会出现惊群 ","date":"2022-08-28","objectID":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/:4:0","tags":["进程线程并发"],"title":"惊群效应","uri":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/"},{"categories":["markdown技术"],"content":"测试插入B站视频链接","date":"2022-08-24","objectID":"/%E6%B5%8B%E8%AF%95markdown%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91/","tags":[""],"title":"测试markdown插入视频","uri":"/%E6%B5%8B%E8%AF%95markdown%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91/"},{"categories":["markdown技术"],"content":"1.测试插入视频 2.测试标题等级 ","date":"2022-08-24","objectID":"/%E6%B5%8B%E8%AF%95markdown%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91/:0:0","tags":[""],"title":"测试markdown插入视频","uri":"/%E6%B5%8B%E8%AF%95markdown%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91/"},{"categories":["markdown技术"],"content":"2.1 二级标题 3.标题 ","date":"2022-08-24","objectID":"/%E6%B5%8B%E8%AF%95markdown%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91/:1:0","tags":[""],"title":"测试markdown插入视频","uri":"/%E6%B5%8B%E8%AF%95markdown%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91/"},{"categories":["markdown技术"],"content":"3.1二级 $ asdf \u003easd$ ","date":"2022-08-24","objectID":"/%E6%B5%8B%E8%AF%95markdown%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91/:2:0","tags":[""],"title":"测试markdown插入视频","uri":"/%E6%B5%8B%E8%AF%95markdown%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91/"},{"categories":["数据库"],"content":"关于MySql数据库常见问题的记录","date":"2022-08-20","objectID":"/mysql%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/","tags":["MySql"],"title":"MySql常见知识点","uri":"/mysql%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["数据库"],"content":"1.一级标题 asfas 啊士大夫 ","date":"2022-08-20","objectID":"/mysql%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/:0:0","tags":["MySql"],"title":"MySql常见知识点","uri":"/mysql%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["算法"],"content":"关于区间调度算法由浅入深的思考","date":"2022-08-20","objectID":"/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/","tags":["操作系统算法"],"title":"区间调度算法","uri":"/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"1.最多区间调度问题 问题的目标是求不重叠的最多区间个数，贪心算法求解：在可选的工作中，每次都选取结束时间最早的工作 const int MAX_N=100000; //输入 int N,S[MAX_N],T[MAX_N]; //用于对工作排序的pair数组 pair\u003cint,int\u003e itv[MAX_N]; void solve() { //对pair进行的是字典序比较，为了让结束时间早的工作排在前面，把T存入first，//把S存入second for(int i=0;i\u003cN;i++) { itv[i].first=T[i]; itv[i].second=S[i]; } sort(itv,itv+N); //t是最后所选工作的结束时间 int ans=0,t=0; for(int i=0;i\u003cN;i++) { if(t\u003citv[i].second)//判断区间是否重叠 { ans++; t=itv[i].first; } } printf(“%d\\n”,ans); } 时间复杂度：O(nlogn) 2.最大区间调度 不重叠的累加区间长度，动态规划算法:按照结束时间排序区间，然后按照第i个区间选择与否进行动态规划 const int MAX_N=100000; //输入 int N,S[MAX_N],T[MAX_N]; //用于对工作排序的pair数组 pair\u003cint,int\u003e itv[MAX_N]; void solve() { //对pair进行的是字典序比较，为了让结束时间早的工作排在前面，把T存入first，//把S存入second for(int i=0;i\u003cN;i++) { itv[i].first=T[i]; itv[i].second=S[i]; } sort(itv,itv+N); dp[0] = itv[0].first-itv[0].second; for (int i = 1; i \u003c N; i++) { int max; //select the ith interval int nonOverlap = lower_bound(itv, itv[i].second)-1; if (nonOverlap \u003e= 0) max = dp[nonOverlap] + (itv[i].first-itv[i].second); else max = itv[i].first-itv[i].second; //do not select the ith interval dp[i] = max\u003edp[i-1]?max:dp[i-1]; } printf(“%d\\n”,dp[N-1]); } 3.带权区间调度 在每个区间上绑定一个权重，求加权之后的区间长度最大值 const int MAX_N=100000; //输入 int N,S[MAX_N],T[MAX_N]; //用于对工作排序的pair数组 pair\u003cint,int\u003e itv[MAX_N]; void solve() { //对pair进行的是字典序比较，为了让结束时间早的工作排在前面，把T存入first，//把S存入second for(int i=0;i\u003cN;i++) { itv[i].first=T[i]; itv[i].second=S[i]; } sort(itv,itv+N); dp[0] = (itv[0].first-itv[0].second)*V[0]; for (int i = 1; i \u003c N; i++) { int max; //select the ith interval int nonOverlap = lower_bound(itv, itv[i].second)-1; if (nonOverlap \u003e= 0) max = dp[nonOverlap] + (itv[i].first-itv[i].second)*V[i]; else max = (itv[i].first-itv[i].second)*V[i]; //do not select the ith interval dp[i] = max\u003edp[i-1]?max:dp[i-1]; } printf(“%d\\n”,dp[N-1]); } 带权区间调度应用最广，最大区间调度其次，最多区间调度应用范围最小。从通用的DP到特殊的DP再到贪心算法，难度逐渐降低。下图展示了三个问题的关系： ","date":"2022-08-20","objectID":"/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/:0:0","tags":["操作系统算法"],"title":"区间调度算法","uri":"/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"关于处理海量数据的思路与常用数据结构","date":"2022-08-20","objectID":"/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95/","tags":["海量数据"],"title":"海量数据处理算法","uri":"/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"1.一级标题","date":"2022-08-20","objectID":"/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95/:0:0","tags":["海量数据"],"title":"海量数据处理算法","uri":"/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95/"}]