[{"categories":["算法"],"content":"1.求矩阵中子矩阵的最大值 Leetcode原题： 面试题 17.24. 最大子矩阵 - 力扣（LeetCode） 就是求解一个矩阵中，所有子矩阵的最大值(子矩阵元素之和)，返回子矩阵的左上和右下坐标值 class Solution { public int[] getMaxMatrix(int[][] matrix) { int[] ans = new int[4];//保存最大子矩阵的左上角和右下角的行列坐标 //N:行，M:列 int N = matrix.length, M = matrix[0].length; int sum; int maxSum = Integer.MIN_VALUE; int startX = -1, startY = -1; for (int i = 0; i \u003c N; i++) {//i为上界，从上往下扫描 int[] b = new int[M];//记录当前i~j行组成大矩阵的每一列的和 for (int j = i; j \u003c N; j++) {//子矩阵的下界，从i~N-1 sum = 0; for (int k = 0; k \u003c M; k++) {//遍历所有列 b[k] += matrix[j][k]; if (sum \u003e 0) { sum += b[k]; } else { sum = b[k];//\u003c0,舍弃之前的,重新计算sum startX = i; startY = k; } if (sum \u003e= maxSum) { maxSum = sum; ans[0] = startX;//更新最终结果 ans[1] = startY;//更新最终结果 ans[2] = j;//更新最终结果 ans[3] = k;//更新最终结果 } } } } return ans; } } 2.求子矩阵中正整数子矩阵的最大值 这一类型的主要特点是：所求的子矩阵的元素类型是有要求的 ","date":"2022-10-04","objectID":"/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/:0:0","tags":["矩阵有关的常见算法"],"title":"矩阵相关算法","uri":"/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"2.1 子矩阵(1)的最大值 剑指 Offer II 040. 矩阵中最大的矩形 - 力扣（LeetCode） 子矩阵必须是1组成的 输入：matrix = [\"10100\",\"10111\",\"11111\",\"10010\"] 输出：6 解释：最大矩形如上图所示。 class Solution { public int maximalRectangle(String[] matrix) { //特判 int m = matrix.length; if (m == 0) { return 0; } int n = matrix[0].length(); //此元素左边的1的个数 int[][] left = new int[m][n]; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (matrix[i].charAt(j) == '1') { //填充left left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1; } } } int ret = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { //不符合，跳过 if (matrix[i].charAt(j) == '0') { continue; } //width=1的长度 int width = left[i][j]; int area = width;//area=wide*1; for (int k = i - 1; k \u003e= 0; k--) { //只能依最小的作为子矩阵的宽 width = Math.min(width, left[k][j]); area = Math.max(area, (i - k + 1) * width); } ret = Math.max(ret, area); } } return ret; } } ","date":"2022-10-04","objectID":"/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/:1:0","tags":["矩阵有关的常见算法"],"title":"矩阵相关算法","uri":"/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"2.1 子矩阵(非0元素)的最大值 这种类型的特点是，子矩阵只能由非0元素组成 如上图，最大子矩阵为标红部分，最大值为：26 /* * 矩阵中的子矩形最大值 */ public class Main1 { static int[][] arr; static int m, n; public static void main(String[] args) { Scanner sc = new Scanner(System.in); m = sc.nextInt(); n = sc.nextInt(); arr = new int[m][n]; sc.nextLine(); for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { arr[i][j] = sc.nextInt(); } } //============逻辑代码============== //特判： if (m == 0) { System.out.println(0); return; } //(i,j)元素的左边非0元素的个数，包括这个元素 int[][] left = new int[m][n]; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (arr[i][j] != 0) { left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1; } } } //转化为一系列的柱状图 int ret = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { //以arr[i][j]为右下角的矩阵 if (arr[i][j] == 0) { continue; } int width = left[i][j]; int area = getArea(i, j, width, 1);//一行的面积 for (int k = i - 1; k \u003e= 0; k--) {//往上遍历 width = Math.min(width, left[k][j]);//只能依最短的宽度 area = Math.max(area, getArea(i, j, width, (i - k + 1))); } ret = Math.max(ret, area); } } System.out.println(ret); } public static int getArea(int x, int y, int kuan, int gao) { int sum = 0; //求一个矩形里数字的和 for (int i = x - gao + 1; i \u003c= x; i++) { for (int j = y - kuan + 1; j \u003c= y; j++) { sum += arr[i][j]; } } return sum; } } ","date":"2022-10-04","objectID":"/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/:2:0","tags":["矩阵有关的常见算法"],"title":"矩阵相关算法","uri":"/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"},{"categories":["go框架"],"content":"关于Gorm框架的使用一些小坑","date":"2022-09-25","objectID":"/gorm%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","tags":["gorm框架"],"title":"Gorm框架的使用注意事项","uri":"/gorm%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"categories":["go框架"],"content":"1.删除指令 //1.软删除----模型包含了一个 gorm.deletedat 字段 db.Delete(\u0026user) // UPDATE users SET deleted_at=\"2013-10-29 10:23\" WHERE id = 111; //2.永久删除 db.Unscoped().Delete(\u0026order) // DELETE FROM orders WHERE id=10; 2.ErrRecordNotFound Gorm框架有时，查不到数据会返回RecordNotFound错误，但并不是真的发生逻辑错误 user = \u0026User{} res := db.First(user) //可以通过user==null来判断是否查到数据 //配置文件忽略查询结果为空的错误 ignore_record_not_found_error: true 3.SkipDefaultTransaction 在事务内执行写入（创建/更新/删除）操作以确保数据一致性，这对性能不利，可以在关闭默认事务 db, err := gorm.Open(sqlite.Open(\"gorm.db\"), \u0026gorm.Config{ SkipDefaultTransaction: true, }) 4.事务里的find 事务里的find语句是默认不加锁，使用以下语句才会加锁 tx.Clauses(clause.Locking{Strength: \"UPDATE\"}).Find(\u0026acc, \"id=?\", id) for i := 0; i \u003c 100; i++ { go func() { defer func() { wg.Done() }() db.Transaction(func(tx *gorm.DB) error { acc := Account{} //1.先Find数据 res := tx.Clauses(clause.Locking{Strength: \"UPDATE\"}).Find(\u0026acc, \"id=?\", id) if res.Error != nil { return res.Error } //2.库存加一 acc.Balance += 1 //3.保存 res = tx.Save(\u0026acc) if res.Error != nil { return res.Error } return nil }) }() } wg.Wait() 5.事务里发生异常 gorm发生异常会回滚，此次操作相当于没有 for i := 0; i \u003c 100; i++ { j := i go func() { //1.此处recover，使异常止于此goroutine defer func() { if err := recover(); err != nil { } wg.Done() }() db.Transaction(func(tx *gorm.DB) error { acc := Account{} res := tx.Clauses(clause.Locking{Strength: \"UPDATE\"}).Find(\u0026acc, \"id=?\", id) if res.Error != nil { return res.Error } acc.Balance += 1 res = tx.Save(\u0026acc) if res.Error != nil { return res.Error } //2.手工制造异常，此两次操作会被回滚 if j == 2 || j == 4 { panic(\"j = 2 or 4 exit\") } return nil }) }() } wg.Wait() ","date":"2022-09-25","objectID":"/gorm%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/:0:0","tags":["gorm框架"],"title":"Gorm框架的使用注意事项","uri":"/gorm%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"categories":[""],"content":" 一下是关于LoveIt的优化帖子： https://lewky.cn/posts/hugo-3.html/ https://lewky.cn/posts/hugo-3.1.html/ https://lewky.cn/posts/hugo-3.2.html/ https://lewky.cn/posts/hugo-3-3/ ","date":"2022-08-30","objectID":"/loveit%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BC%98%E5%8C%96/:0:0","tags":[""],"title":"LoveIt主题的优化","uri":"/loveit%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BC%98%E5%8C%96/"},{"categories":[""],"content":"1.正向代理和反向代理","date":"2022-08-29","objectID":"/nignx%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/:0:0","tags":[""],"title":"Nignx常见面试题","uri":"/nignx%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["操作系统"],"content":"关于惊群效应的简单介绍和总结","date":"2022-08-28","objectID":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/","tags":["进程线程并发"],"title":"惊群效应","uri":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/"},{"categories":["操作系统"],"content":"1.简介 当你往一群鸽子中间扔一块食物，虽然最终只有一个鸽子抢到食物，但所有鸽子都会被惊动来争夺，没有抢到食物的鸽子只好回去继续睡觉， 等待下一块食物到来。这样，每扔一块食物，都会惊动所有的鸽子，即为惊群。 操作系统的惊群 在多进程/多线程等待同一资源时，也会出现惊群。即当某一资源可用时，多个进程/线程会惊醒，竞争资源。 2.惊群的影响 惊醒所有进程/线程，导致n-1个进程/线程做了无效的调度，上下文切换，cpu瞬时增高 多个进程/线程争抢资源，所以涉及到同步问题，需对资源进行加锁保护，加解锁加大系统CPU开销 但在某些情况，惊群次数少，进（线）程负载不高，惊群可以忽略不计 3.惊群的情况 accept惊群 epoll惊群 nginx惊群 线程池惊群 ","date":"2022-08-28","objectID":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/:0:0","tags":["进程线程并发"],"title":"惊群效应","uri":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/"},{"categories":["操作系统"],"content":"3.1 accept惊群 新版内核已解决 以多进程为例，在主进程创建监听描述符listenfd后，fork()多个子进程，多个进程共享listenfd，accept是在每个子进程中，当一个新连接来的时候，会发生惊群。 主线程创建了监听描述符listenfd = 3 主线程fork三个子进程，共享listenfd=3 当有新连接进来时，内核进行处理 在内核2.6之前，所有进程accept都会惊醒，但只有一个可以accept成功，其他返回EGAIN。 在内核2.6及之后，解决了惊群，在内核中增加了一个互斥等待变量。一个互斥等待的行为与睡眠基本类似，主要的不同点在于： 1）当一个等待队列入口有 WQ_FLAG_EXCLUSEVE 标志置位, 它被添加到等待队列的尾部；没有这个标志的入口项，相反, 添加到开始。 2）当 wake_up 被在一个等待队列上调用时, 它在唤醒第一个有 WQ_FLAG_EXCLUSIVE 标志的进程后停止。 对于互斥等待的行为，比如对一个listen后的socket描述符，多线程阻塞accept时，系统内核只会唤醒所有正在等待此时间的队列的第一个，队列中的其他人则继续等待下一次事件的发生，这样就避免的多个线程同时监听同一个socket描述符时的惊群问题。 ","date":"2022-08-28","objectID":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/:1:0","tags":["进程线程并发"],"title":"惊群效应","uri":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/"},{"categories":["操作系统"],"content":"3.2 epoll惊群 ","date":"2022-08-28","objectID":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/:2:0","tags":["进程线程并发"],"title":"惊群效应","uri":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/"},{"categories":["操作系统"],"content":"3.2.1 fork之前创建epollfd 新版内核(2.6之后)已解决 主进程创建listenfd, 创建epollfd 主进程fork多个子进程 每个子进程把listenfd,加到epollfd中 当一个连接进来时，会触发epoll惊群，多个子进程的epoll同时会触发 这里的epoll惊群跟accept惊群是类似的，共享一个epollfd, 可以通过加锁或标记解决。 ","date":"2022-08-28","objectID":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/:2:1","tags":["进程线程并发"],"title":"惊群效应","uri":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/"},{"categories":["操作系统"],"content":"3.2.2 fork之后创建epollfd 内核未解决 主进程创建listendfd 主进程fork创建多个子进程 每个子进程创建自已的epollfd 每个子进程把listenfd加入到epollfd中 当一个连接进来时，会触发epoll惊群，多个子进程epoll同时会触发 因为每个子进程的epoll是不同的epoll，虽然listenfd是同一个，但新连接过来时, accept会触发惊群，但内核不知道该发给哪个监听进程，因为不是同一个epoll。所以这种惊群内核并没有处理。惊群还是会出现。 ","date":"2022-08-28","objectID":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/:2:2","tags":["进程线程并发"],"title":"惊群效应","uri":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/"},{"categories":["操作系统"],"content":"3.3 Nginx惊群 在nginx中使用的epoll，是在创建进程后创建的epollfd。因些会出现惊群问题。即每个子进程worker都会惊醒。 Nginx流程： 1 主线程创建listenfd 2 主线程fork多个子进程（根据配置） 3 子进程创建epollfd 4 获到accept锁，只有一个子进程把listenfd加到epollfd中 同一时间只有一个进程会把监听描述符加到epoll中 5 循环监听 nginx里采用了主动的方法去把监听描述符放到epoll中或从epoll移出（这个是nginx的精髓所在，因为大部份的并发架构都是被动的） nginx中用采互斥锁去解决谁来accept问题，保证了同一时刻，只有一个worker接收新连接（所以nginx并没有惊群问题） nginx根据自已的载负（最大连接的7/8）情况，决定去不去抢锁，简单方便地解决负载，防止进程因业务太多而导致所有业务都不及时处理 ","date":"2022-08-28","objectID":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/:3:0","tags":["进程线程并发"],"title":"惊群效应","uri":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/"},{"categories":["操作系统"],"content":"3.4线程池惊群 当一个线程解锁并通知其他线程的时候，就会出现惊群的现象 正常的用法： 所有线程共用一个锁，共用一个条件变量 当pthread_cond_signal通知时，就可能会出现惊群 解决惊群的方法： 所有线程共用一个锁，每个线程有自已的条件变量 pthread_cond_signal通知时，定向通知某个线程的条件变量，不会出现惊群 ","date":"2022-08-28","objectID":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/:4:0","tags":["进程线程并发"],"title":"惊群效应","uri":"/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/"},{"categories":["markdown技术"],"content":"测试插入B站视频链接","date":"2022-08-24","objectID":"/%E6%B5%8B%E8%AF%95markdown%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91/","tags":[""],"title":"测试markdown插入视频","uri":"/%E6%B5%8B%E8%AF%95markdown%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91/"},{"categories":["markdown技术"],"content":"1.测试插入视频 2.测试标题等级 ","date":"2022-08-24","objectID":"/%E6%B5%8B%E8%AF%95markdown%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91/:0:0","tags":[""],"title":"测试markdown插入视频","uri":"/%E6%B5%8B%E8%AF%95markdown%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91/"},{"categories":["markdown技术"],"content":"2.1 二级标题 3.标题 ","date":"2022-08-24","objectID":"/%E6%B5%8B%E8%AF%95markdown%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91/:1:0","tags":[""],"title":"测试markdown插入视频","uri":"/%E6%B5%8B%E8%AF%95markdown%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91/"},{"categories":["markdown技术"],"content":"3.1二级 $ asdf \u003easd$ ","date":"2022-08-24","objectID":"/%E6%B5%8B%E8%AF%95markdown%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91/:2:0","tags":[""],"title":"测试markdown插入视频","uri":"/%E6%B5%8B%E8%AF%95markdown%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91/"},{"categories":["数据库"],"content":"关于MySql数据库常见问题的记录","date":"2022-08-20","objectID":"/mysql%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/","tags":["MySql"],"title":"MySql常见知识点","uri":"/mysql%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["数据库"],"content":"1.一级标题 asfas 啊士大夫 ","date":"2022-08-20","objectID":"/mysql%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/:0:0","tags":["MySql"],"title":"MySql常见知识点","uri":"/mysql%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["算法"],"content":"关于区间调度算法由浅入深的思考","date":"2022-08-20","objectID":"/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/","tags":["操作系统算法"],"title":"区间调度算法","uri":"/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"1.最多区间调度问题 问题的目标是求不重叠的最多区间个数，贪心算法求解：在可选的工作中，每次都选取结束时间最早的工作 const int MAX_N=100000; //输入 int N,S[MAX_N],T[MAX_N]; //用于对工作排序的pair数组 pair\u003cint,int\u003e itv[MAX_N]; void solve() { //对pair进行的是字典序比较，为了让结束时间早的工作排在前面，把T存入first，//把S存入second for(int i=0;i\u003cN;i++) { itv[i].first=T[i]; itv[i].second=S[i]; } sort(itv,itv+N); //t是最后所选工作的结束时间 int ans=0,t=0; for(int i=0;i\u003cN;i++) { if(t\u003citv[i].second)//判断区间是否重叠 { ans++; t=itv[i].first; } } printf(“%d\\n”,ans); } 时间复杂度：O(nlogn) 2.最大区间调度 不重叠的累加区间长度，动态规划算法:按照结束时间排序区间，然后按照第i个区间选择与否进行动态规划 const int MAX_N=100000; //输入 int N,S[MAX_N],T[MAX_N]; //用于对工作排序的pair数组 pair\u003cint,int\u003e itv[MAX_N]; void solve() { //对pair进行的是字典序比较，为了让结束时间早的工作排在前面，把T存入first，//把S存入second for(int i=0;i\u003cN;i++) { itv[i].first=T[i]; itv[i].second=S[i]; } sort(itv,itv+N); dp[0] = itv[0].first-itv[0].second; for (int i = 1; i \u003c N; i++) { int max; //select the ith interval int nonOverlap = lower_bound(itv, itv[i].second)-1; if (nonOverlap \u003e= 0) max = dp[nonOverlap] + (itv[i].first-itv[i].second); else max = itv[i].first-itv[i].second; //do not select the ith interval dp[i] = max\u003edp[i-1]?max:dp[i-1]; } printf(“%d\\n”,dp[N-1]); } 3.带权区间调度 在每个区间上绑定一个权重，求加权之后的区间长度最大值 const int MAX_N=100000; //输入 int N,S[MAX_N],T[MAX_N]; //用于对工作排序的pair数组 pair\u003cint,int\u003e itv[MAX_N]; void solve() { //对pair进行的是字典序比较，为了让结束时间早的工作排在前面，把T存入first，//把S存入second for(int i=0;i\u003cN;i++) { itv[i].first=T[i]; itv[i].second=S[i]; } sort(itv,itv+N); dp[0] = (itv[0].first-itv[0].second)*V[0]; for (int i = 1; i \u003c N; i++) { int max; //select the ith interval int nonOverlap = lower_bound(itv, itv[i].second)-1; if (nonOverlap \u003e= 0) max = dp[nonOverlap] + (itv[i].first-itv[i].second)*V[i]; else max = (itv[i].first-itv[i].second)*V[i]; //do not select the ith interval dp[i] = max\u003edp[i-1]?max:dp[i-1]; } printf(“%d\\n”,dp[N-1]); } 带权区间调度应用最广，最大区间调度其次，最多区间调度应用范围最小。从通用的DP到特殊的DP再到贪心算法，难度逐渐降低。下图展示了三个问题的关系： ","date":"2022-08-20","objectID":"/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/:0:0","tags":["操作系统算法"],"title":"区间调度算法","uri":"/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"关于处理海量数据的思路与常用数据结构","date":"2022-08-20","objectID":"/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95/","tags":["海量数据"],"title":"海量数据处理算法","uri":"/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"1.一级标题","date":"2022-08-20","objectID":"/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95/:0:0","tags":["海量数据"],"title":"海量数据处理算法","uri":"/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95/"}]