[{"categories":["数据库"],"content":"关于MySql数据库常见问题的记录","date":"2022-08-20","objectID":"/mysql%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/","tags":["MySql"],"title":"MySql常见知识点","uri":"/mysql%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["数据库"],"content":"1.一级标题 asfas 啊士大夫 ","date":"2022-08-20","objectID":"/mysql%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/:0:0","tags":["MySql"],"title":"MySql常见知识点","uri":"/mysql%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["算法"],"content":"关于区间调度算法由浅入深的思考","date":"2022-08-20","objectID":"/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/","tags":["操作系统算法"],"title":"区间调度算法","uri":"/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"1.最多区间调度问题 问题的目标是求不重叠的最多区间个数，贪心算法求解：在可选的工作中，每次都选取结束时间最早的工作 const int MAX_N=100000; //输入 int N,S[MAX_N],T[MAX_N]; //用于对工作排序的pair数组 pair\u003cint,int\u003e itv[MAX_N]; void solve() { //对pair进行的是字典序比较，为了让结束时间早的工作排在前面，把T存入first，//把S存入second for(int i=0;i\u003cN;i++) { itv[i].first=T[i]; itv[i].second=S[i]; } sort(itv,itv+N); //t是最后所选工作的结束时间 int ans=0,t=0; for(int i=0;i\u003cN;i++) { if(t\u003citv[i].second)//判断区间是否重叠 { ans++; t=itv[i].first; } } printf(“%d\\n”,ans); } 时间复杂度：O(nlogn) 2.最大区间调度 不重叠的累加区间长度，动态规划算法:按照结束时间排序区间，然后按照第i个区间选择与否进行动态规划 const int MAX_N=100000; //输入 int N,S[MAX_N],T[MAX_N]; //用于对工作排序的pair数组 pair\u003cint,int\u003e itv[MAX_N]; void solve() { //对pair进行的是字典序比较，为了让结束时间早的工作排在前面，把T存入first，//把S存入second for(int i=0;i\u003cN;i++) { itv[i].first=T[i]; itv[i].second=S[i]; } sort(itv,itv+N); dp[0] = itv[0].first-itv[0].second; for (int i = 1; i \u003c N; i++) { int max; //select the ith interval int nonOverlap = lower_bound(itv, itv[i].second)-1; if (nonOverlap \u003e= 0) max = dp[nonOverlap] + (itv[i].first-itv[i].second); else max = itv[i].first-itv[i].second; //do not select the ith interval dp[i] = max\u003edp[i-1]?max:dp[i-1]; } printf(“%d\\n”,dp[N-1]); } 3.带权区间调度 在每个区间上绑定一个权重，求加权之后的区间长度最大值 const int MAX_N=100000; //输入 int N,S[MAX_N],T[MAX_N]; //用于对工作排序的pair数组 pair\u003cint,int\u003e itv[MAX_N]; void solve() { //对pair进行的是字典序比较，为了让结束时间早的工作排在前面，把T存入first，//把S存入second for(int i=0;i\u003cN;i++) { itv[i].first=T[i]; itv[i].second=S[i]; } sort(itv,itv+N); dp[0] = (itv[0].first-itv[0].second)*V[0]; for (int i = 1; i \u003c N; i++) { int max; //select the ith interval int nonOverlap = lower_bound(itv, itv[i].second)-1; if (nonOverlap \u003e= 0) max = dp[nonOverlap] + (itv[i].first-itv[i].second)*V[i]; else max = (itv[i].first-itv[i].second)*V[i]; //do not select the ith interval dp[i] = max\u003edp[i-1]?max:dp[i-1]; } printf(“%d\\n”,dp[N-1]); } 带权区间调度应用最广，最大区间调度其次，最多区间调度应用范围最小。从通用的DP到特殊的DP再到贪心算法，难度逐渐降低。下图展示了三个问题的关系： ","date":"2022-08-20","objectID":"/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/:0:0","tags":["操作系统算法"],"title":"区间调度算法","uri":"/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"关于处理海量数据的思路与常用数据结构","date":"2022-08-20","objectID":"/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95/","tags":["海量数据"],"title":"海量数据处理算法","uri":"/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"1.一级标题","date":"2022-08-20","objectID":"/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95/:0:0","tags":["海量数据"],"title":"海量数据处理算法","uri":"/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95/"}]