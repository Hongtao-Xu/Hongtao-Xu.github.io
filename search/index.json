[{"categories":["go框架"],"contents":"1.删除指令 1 2 3 4 5 6 7 //1.软删除----模型包含了一个 gorm.deletedat 字段 db.Delete(\u0026amp;user) // UPDATE users SET deleted_at=\u0026#34;2013-10-29 10:23\u0026#34; WHERE id = 111; //2.永久删除 db.Unscoped().Delete(\u0026amp;order) // DELETE FROM orders WHERE id=10; 2.ErrRecordNotFound Gorm框架有时，查不到数据会返回RecordNotFound错误，但并不是真的发生逻辑错误 1 2 3 4 5 6 user = \u0026amp;User{} res := db.First(user) //可以通过user==null来判断是否查到数据 //配置文件忽略查询结果为空的错误 ignore_record_not_found_error: true 3.SkipDefaultTransaction 在事务内执行写入（创建/更新/删除）操作以确保数据一致性，这对性能不利，可以在关闭默认事务 1 2 3 db, err := gorm.Open(sqlite.Open(\u0026#34;gorm.db\u0026#34;), \u0026amp;gorm.Config{ SkipDefaultTransaction: true, }) 4.事务里的find 事务里的find语句是默认不加锁，使用以下语句才会加锁 tx.Clauses(clause.Locking{Strength: \u0026quot;UPDATE\u0026quot;}).Find(\u0026amp;acc, \u0026quot;id=?\u0026quot;, id) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 for i := 0; i \u0026lt; 100; i++ { go func() { defer func() { wg.Done() }() db.Transaction(func(tx *gorm.DB) error { acc := Account{} //1.先Find数据 res := tx.Clauses(clause.Locking{Strength: \u0026#34;UPDATE\u0026#34;}).Find(\u0026amp;acc, \u0026#34;id=?\u0026#34;, id) if res.Error != nil { return res.Error } //2.库存加一 acc.Balance += 1 //3.保存 res = tx.Save(\u0026amp;acc) if res.Error != nil { return res.Error } return nil }) }() } wg.Wait() 5.事务里发生异常 gorm发生异常会回滚，此次操作相当于没有 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 for i := 0; i \u0026lt; 100; i++ { j := i go func() { //1.此处recover，使异常止于此goroutine defer func() { if err := recover(); err != nil { } wg.Done() }() db.Transaction(func(tx *gorm.DB) error { acc := Account{} res := tx.Clauses(clause.Locking{Strength: \u0026#34;UPDATE\u0026#34;}).Find(\u0026amp;acc, \u0026#34;id=?\u0026#34;, id) if res.Error != nil { return res.Error } acc.Balance += 1 res = tx.Save(\u0026amp;acc) if res.Error != nil { return res.Error } //2.手工制造异常，此两次操作会被回滚 if j == 2 || j == 4 { panic(\u0026#34;j = 2 or 4 exit\u0026#34;) } return nil }) }() } wg.Wait() ","permalink":"https://hongtao-xu.github.io/gorm%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","tags":["gorm框架"],"title":"Gorm框架的使用注意事项"},{"categories":[""],"contents":" 一下是关于LoveIt的优化帖子： https://lewky.cn/posts/hugo-3.html/ https://lewky.cn/posts/hugo-3.1.html/ https://lewky.cn/posts/hugo-3.2.html/ https://lewky.cn/posts/hugo-3-3/ ","permalink":"https://hongtao-xu.github.io/loveit%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BC%98%E5%8C%96/","tags":[""],"title":"LoveIt主题的优化"},{"categories":[""],"contents":"1.正向代理和反向代理","permalink":"https://hongtao-xu.github.io/nignx%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/","tags":[""],"title":"Nignx常见面试题"},{"categories":["操作系统"],"contents":"1.简介 当你往一群鸽子中间扔一块食物，虽然最终只有一个鸽子抢到食物，但所有鸽子都会被惊动来争夺，没有抢到食物的鸽子只好回去继续睡觉， 等待下一块食物到来。这样，每扔一块食物，都会惊动所有的鸽子，即为惊群。 操作系统的惊群 在多进程/多线程等待同一资源时，也会出现惊群。即当某一资源可用时，多个进程/线程会惊醒，竞争资源。 2.惊群的影响 惊醒所有进程/线程，导致n-1个进程/线程做了无效的调度，上下文切换，cpu瞬时增高 多个进程/线程争抢资源，所以涉及到同步问题，需对资源进行加锁保护，加解锁加大系统CPU开销 但在某些情况，惊群次数少，进（线）程负载不高，惊群可以忽略不计 3.惊群的情况 accept惊群 epoll惊群 nginx惊群 线程池惊群 3.1 accept惊群 新版内核已解决 以多进程为例，在主进程创建监听描述符listenfd后，fork()多个子进程，多个进程共享listenfd，accept是在每个子进程中，当一个新连接来的时候，会发生惊群。 主线程创建了监听描述符listenfd = 3 主线程fork三个子进程，共享listenfd=3 当有新连接进来时，内核进行处理 在内核2.6之前，所有进程accept都会惊醒，但只有一个可以accept成功，其他返回EGAIN。 在内核2.6及之后，解决了惊群，在内核中增加了一个互斥等待变量。一个互斥等待的行为与睡眠基本类似，主要的不同点在于： 1）当一个等待队列入口有 WQ_FLAG_EXCLUSEVE 标志置位, 它被添加到等待队列的尾部；没有这个标志的入口项，相反, 添加到开始。 2）当 wake_up 被在一个等待队列上调用时, 它在唤醒第一个有 WQ_FLAG_EXCLUSIVE 标志的进程后停止。 对于互斥等待的行为，比如对一个listen后的socket描述符，多线程阻塞accept时，系统内核只会唤醒所有正在等待此时间的队列的第一个，队列中的其他人则继续等待下一次事件的发生，这样就避免的多个线程同时监听同一个socket描述符时的惊群问题。 3.2 epoll惊群 3.2.1 fork之前创建epollfd 新版内核(2.6之后)已解决 主进程创建listenfd, 创建epollfd 主进程fork多个子进程 每个子进程把listenfd,加到epollfd中 当一个连接进来时，会触发epoll惊群，多个子进程的epoll同时会触发 这里的epoll惊群跟accept惊群是类似的，共享一个epollfd, 可以通过加锁或标记解决。 3.2.2 fork之后创建epollfd 内核未解决 主进程创建listendfd 主进程fork创建多个子进程 每个子进程创建自已的epollfd 每个子进程把listenfd加入到epollfd中 当一个连接进来时，会触发epoll惊群，多个子进程epoll同时会触发 因为每个子进程的epoll是不同的epoll，虽然listenfd是同一个，但新连接过来时, accept会触发惊群，但内核不知道该发给哪个监听进程，因为不是同一个epoll。所以这种惊群内核并没有处理。惊群还是会出现。 3.3 Nginx惊群 在nginx中使用的epoll，是在创建进程后创建的epollfd。因些会出现惊群问题。即每个子进程worker都会惊醒。 Nginx流程： 1 主线程创建listenfd 2 主线程fork多个子进程（根据配置） 3 子进程创建epollfd 4 获到accept锁，只有一个子进程把listenfd加到epollfd中 同一时间只有一个进程会把监听描述符加到epoll中 5 循环监听 nginx里采用了主动的方法去把监听描述符放到epoll中或从epoll移出（这个是nginx的精髓所在，因为大部份的并发架构都是被动的） nginx中用采互斥锁去解决谁来accept问题，保证了同一时刻，只有一个worker接收新连接（所以nginx并没有惊群问题） nginx根据自已的载负（最大连接的7/8）情况，决定去不去抢锁，简单方便地解决负载，防止进程因业务太多而导致所有业务都不及时处理 3.4线程池惊群 当一个线程解锁并通知其他线程的时候，就会出现惊群的现象 正常的用法： 所有线程共用一个锁，共用一个条件变量 当pthread_cond_signal通知时，就可能会出现惊群 解决惊群的方法： 所有线程共用一个锁，每个线程有自已的条件变量 pthread_cond_signal通知时，定向通知某个线程的条件变量，不会出现惊群 ","permalink":"https://hongtao-xu.github.io/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/","tags":["进程线程并发"],"title":"惊群效应"},{"categories":["markdown技术"],"contents":"1.测试插入视频 2.测试标题等级 2.1 二级标题 3.标题 3.1二级 $ asdf \u0026gt;asd$ ","permalink":"https://hongtao-xu.github.io/%E6%B5%8B%E8%AF%95markdown%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91/","tags":[""],"title":"测试markdown插入视频"},{"categories":["数据库"],"contents":"1.一级标题 asfas 啊士大夫 ","permalink":"https://hongtao-xu.github.io/mysql%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/","tags":["MySql"],"title":"MySql常见知识点"},{"categories":["算法"],"contents":"1.最多区间调度问题 问题的目标是求不重叠的最多区间个数，贪心算法求解：在可选的工作中，每次都选取结束时间最早的工作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 const int MAX_N=100000; //输入 int N,S[MAX_N],T[MAX_N]; //用于对工作排序的pair数组 pair\u0026lt;int,int\u0026gt; itv[MAX_N]; void solve() { //对pair进行的是字典序比较，为了让结束时间早的工作排在前面，把T存入first，//把S存入second for(int i=0;i\u0026lt;N;i++) { itv[i].first=T[i]; itv[i].second=S[i]; } sort(itv,itv+N); //t是最后所选工作的结束时间 int ans=0,t=0; for(int i=0;i\u0026lt;N;i++) { if(t\u0026lt;itv[i].second)//判断区间是否重叠 { ans++; t=itv[i].first; } } printf(“%d\\n”,ans); } 时间复杂度：O(nlogn) 2.最大区间调度 不重叠的累加区间长度，动态规划算法:按照结束时间排序区间，然后按照第i个区间选择与否进行动态规划 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 const int MAX_N=100000; //输入 int N,S[MAX_N],T[MAX_N]; //用于对工作排序的pair数组 pair\u0026lt;int,int\u0026gt; itv[MAX_N]; void solve() { //对pair进行的是字典序比较，为了让结束时间早的工作排在前面，把T存入first，//把S存入second for(int i=0;i\u0026lt;N;i++) { itv[i].first=T[i]; itv[i].second=S[i]; } sort(itv,itv+N); dp[0] = itv[0].first-itv[0].second; for (int i = 1; i \u0026lt; N; i++) { int max; //select the ith interval int nonOverlap = lower_bound(itv, itv[i].second)-1; if (nonOverlap \u0026gt;= 0) max = dp[nonOverlap] + (itv[i].first-itv[i].second); else max = itv[i].first-itv[i].second; //do not select the ith interval dp[i] = max\u0026gt;dp[i-1]?max:dp[i-1]; } printf(“%d\\n”,dp[N-1]); } 3.带权区间调度 在每个区间上绑定一个权重，求加权之后的区间长度最大值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 const int MAX_N=100000; //输入 int N,S[MAX_N],T[MAX_N]; //用于对工作排序的pair数组 pair\u0026lt;int,int\u0026gt; itv[MAX_N]; void solve() { //对pair进行的是字典序比较，为了让结束时间早的工作排在前面，把T存入first，//把S存入second for(int i=0;i\u0026lt;N;i++) { itv[i].first=T[i]; itv[i].second=S[i]; } sort(itv,itv+N); dp[0] = (itv[0].first-itv[0].second)*V[0]; for (int i = 1; i \u0026lt; N; i++) { int max; //select the ith interval int nonOverlap = lower_bound(itv, itv[i].second)-1; if (nonOverlap \u0026gt;= 0) max = dp[nonOverlap] + (itv[i].first-itv[i].second)*V[i]; else max = (itv[i].first-itv[i].second)*V[i]; //do not select the ith interval dp[i] = max\u0026gt;dp[i-1]?max:dp[i-1]; } printf(“%d\\n”,dp[N-1]); } 带权区间调度应用最广，最大区间调度其次，最多区间调度应用范围最小。从通用的DP到特殊的DP再到贪心算法，难度逐渐降低。下图展示了三个问题的关系： ","permalink":"https://hongtao-xu.github.io/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/","tags":["操作系统算法"],"title":"区间调度算法"},{"categories":["算法"],"contents":"1.一级标题","permalink":"https://hongtao-xu.github.io/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95/","tags":["海量数据"],"title":"海量数据处理算法"},{"categories":null,"contents":"","permalink":"https://hongtao-xu.github.io/search/","tags":null,"title":"Search"}]